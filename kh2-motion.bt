// Use kh2-bar.bt

struct T1 {
    ushort joint;
    ushort channel;
    float value;
};

string commentT1(T1 &r) {
    string s = "";
    SPrintf(s, "%u, %u, %f", r.joint, r.channel, r.value);
    return s;
}

struct T2 {
    ushort joint;
    ubyte channel:4;
    ubyte pre:2;
    ubyte post:2;
    ubyte keyCount;
    ushort t9Idx;
};

string commentT2(T2 &r) {
    string s = "";
    SPrintf(s, "%u, %u, %u, %u, %u, %u"
        , r.joint
        , r.channel
        , r.pre
        , r.post
        , r.keyCount
        , r.t9Idx
    );
    return s;
}

struct T3 {
    byte action;
    byte unk1;
    ushort targetIdx;
    ushort srcIdx;
    ushort unk2;
    uint unk3;
};

string commentT3(T3 &r) {
    string s = "";
    SPrintf(s, "%u, %u, %u, %u, %u, %u"
        , r.action
        , r.unk1
        , r.targetIdx
        , r.srcIdx
        , r.unk2
        , r.unk3
    );
    return s;
}

struct T4 {
    ushort joint;
    ushort flags <format=hex>;
};

string commentT4(T4 &r) {
    string s = "";
    SPrintf(s, "%u, 0x%02X"
        , r.joint
        , r.flags
    );
    return s;
}

struct AxBone {
    int index;
    int parent;
    int unk[2];
    float sx, sy, sz, sw;
    float rx, ry, rz, rw;
    float tx, ty, tz, tw;
};

string commentAxBone(AxBone &r) {
    string s = "";
    SPrintf(s, "%d, %d"
        , r.index
        , r.parent
    );
    return s;
}

struct T9 {
    ushort interp:2;
    ushort t11Idx:14;
    ushort t10Idx;
    ushort t12IdxA;
    ushort t12IdxB;
};

string commentT9(T9 &r) {
    string s = "";
    SPrintf(s, "%u, %u, %u, %u, %u"
        , r.interp
        , r.t11Idx
        , r.t10Idx
        , r.t12IdxA
        , r.t12IdxB
    );
    return s;
}

struct T6 {
    short a;
    short boneIdx;
    float c;
    short nextIdx1;
    short nextIdx2;
};

struct T7 {
    short boneIdx;
    short channel;
    short c;
    short t6Idx;
};

struct T8 {
    int a;
    int b;
    float c;
    float d;
    float e0;
    float e1;
    float e2;
    float e3;
    float f0;
    float f1;
    float f2;
    float f3;
};

struct MotionHeader (int64 top) {
    uint version;
    uint unk1a;
    uint byteCount;
    uint unk1b;
    
    // 0: compressed format
    if (version == 0) {
        ushort cntBones1;
        ushort cntBones2;
        uint TotalFrameCount;
        uint offT5 <format=hex>;
        uint offT4 <format=hex>;
    
        uint cntT11;
        uint offT1 <format=hex>;
        uint cntT1;
        uint unkOff1 <format=hex>;
    
        uint offT2 <format=hex>;
        uint cntT2;
        uint offT2x <format=hex>;
        uint cntT2x;
    
        uint offT9 <format=hex>;
        uint offT11 <format=hex>;
        uint offT10 <format=hex>;
        uint offT12 <format=hex>;
    
        uint offT3 <format=hex>;
        uint cntT3;
        uint unkOff2 <format=hex>;
        uint offT8 <format=hex>;
    
        uint offT7 <format=hex>;
        uint cntT7;
        uint offT6 <format=hex>;
        uint cntT6;

        float min[4];
        float max[4];
        float FrameLoop;
        float FrameEnd;
        float FramePerSecond;
        float FrameCount;
        uint unk5[4];

        FSeek(top +offT1);
        T1 t1[cntT1] <comment=commentT1>;
    
        FSeek(top +offT2);
        T2 t2[cntT2] <comment=commentT2>;
    
        FSeek(top +offT2x);
        T2 t2x[cntT2x] <comment=commentT2>;
    
        FSeek(top +offT9);
        T9 t9[1] <comment=commentT9>;

        FSeek(top +offT11);
        float t11[1];

        FSeek(top +offT10);
        float t10[1];

        FSeek(top +offT12);
        float t12[1];

        FSeek(top +offT3);
        T3 t3[cntT3] <comment=commentT3>;

        FSeek(top +unkOff2);
        int unk2;

        FSeek(top +offT8);
        T8 t8[(offT7-offT8)/48];

        FSeek(top +offT7);
        T7 t7[cntT7];

        FSeek(top +offT6);
        T6 t6[cntT6];

        FSeek(top +offT5);
        AxBone t5[cntBones2-cntBones1]  <comment=commentAxBone>;

        FSeek(top +offT4);
        T4 t4[cntBones2] <comment=commentT4>;

        FSeek(top +unkOff1);
        float unkvec[4*3];
    }
    // 1: uncompressed form
    if (version == 1) {
        // format imported from OpenKh:
        // - https://github.com/Xeeynamo/OpenKh/pull/293/files
        uint BoneCount;
        uint Unk14;
        uint Unk18;
        uint Unk1c;

        uint Unk20;
        uint TotalFrameCount;
        uint Unk28;
        uint Unk2c;

        float min[4];
        float max[4];
        float FrameLoop;
        float FrameEnd;
        float FramePerSecond;
        float FrameCount;
        
        float Matrices[16*BoneCount*TotalFrameCount];
    }

};

void ReadMotionHeader() {
    FSkip(0x90);
    local int64 top = FTell();
    MotionHeader motion(top);
}
